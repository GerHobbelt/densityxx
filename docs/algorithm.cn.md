density 算法介绍
================

chameleon，变色龙算法
---------------------

这个算法较为简单，其主旨是：
* 压缩及字典维护：
  * 把整个输入流看作一个 uint32_t 的序列，每个 uint32_t 叫做一个 chunk;
  * 利用一个从 uint32_t -> uint16_t 的 hash 算法，把输入的 uint32_t 变换为 uint16_t；
  * 维护一个含有 2^16 个 uint32_t 的字典，用以上 hash 算法的输出作为索引，从原始数据流中提取的 uint32_t 作为值；
  * 压缩时，针对每个 chunk，计算出相应的 hash 值，如果：
    * 字典中 hash 值给出的位置储存的就是 chunk，就直接用 hash 值来代替 chunk，这就实现了从 4 字节到 2 字节的压缩；
    * 若字典中 hash 值给出的位置储存的不是 chunk 值，则只能在输出流中直接写出 chunk，这时输入输出都是 4 个字节，没有达到压缩效果。于此同时，要将 chunk 值填充到字典中，以备下次出现时，可以用 hash 值来代替 chunk 值；
  * 需要做到的只是把临近的、反复出现的 chunk 值替换为 hash 值，从而实现压缩。它并不需要处理任何冲突，因为处理冲突的代价比放弃替换机会更大，所以还不如不处理冲突；
* 签名及分块：
  * 由于解压程序，并无法分辨其获得的究竟是 chunk 值还是 hash 值。因此必须配备 signature 进行区分；
  * 考虑到 C++ 支持的最大字长的整数是 uint64_t，且只需要区分 chunk/hash 两种情况，因此每 64 个 chunk 可以用一个类型为 uint64_t 的 signature 来标志；
  * 因此，每 64 个输入 chunk 构成一个 block，一个 block 以 uint64_t 的 signature 为头，随后含有 64 个 hash(uint16_t) 或者 chunk(uint32_t)；
* 结尾处理：
  * 输入流的字节数，即不会向 4 字节(uint32_t) 对齐，更不会向 block 对齐。因此必须有决定最后一个 block 中有多少 chunk，最后一个 chunk 中有多少字节的问题；
  * 本算法的输入输出顺序完全对应，只要输入结束时输出也结束。最后一个 chunk 若完整利用字典试图变换为 hash，若不完整则保持不变(内容和字节数都保持不变)即可;
  * 解压缩时，按基本规则处理数据。若输入数据结束时，恰好处理完一个 chunk 则输出也可同时结束。若最后一个 chunk 处理完毕后还有剩余的数据(必然是 1-3 个字节)，则直接复制到输出后结束即可。

针对 chameleon 算法，可以：
* 选择不同的 chunk、hash 字长。当前的字长分别是 uint32_t、uint16_t，也可以考虑选择 uint64_t、uint16_t。但 hash_t 的字长不宜太短，太容易冲突；
* 选择不同的 hash 算法，不同的 hash 算法效率不同，匹配几率也会有不同。例如不同的换算公式，不同的换算参数，或者增加冲突处理策略；
* 选择不同的初始字典。当前的初始字典是全 0, 可在特殊场合下选择初始字典，以提高压缩流之中 hash 值出现的几率，从而提高压缩率。



